{"version":3,"sources":["components/Settings/Import/Import.constants.js","components/Settings/Import/Import.helpers.js","../node_modules/jszip-utils/lib/index.js"],"names":["IMPORT_CONFIG_BY_EXTENSION","json","cboardImportAdapter","zip","obzImportAdapter","obz","obf","obfImportAdapter","IMPORT_PATHS","boards","images","CBOARD_EXT_PREFIX","EXPORT_CBOARD_EXT_PREFIX","CBOARD_EXT_PROPERTIES","EXPORT_CBOARD_EXT_PROPERTIES","toCamelCase","scString","find","convertFn","matches","toUpperCase","replace","readZip","file","a","Promise","resolve","reader","FileReader","onload","event","target","readyState","Blob","result","err","readAsArrayBuffer","zipBlob","reject","filePath","URL","createObjectURL","JSZipUtils","getBinaryContent","data","JSZip","loadAsync","obfButtonToCboardButton","button","cboardButton","id","shortid","generate","label","backgroundColor","borderColor","vocalization","action","getTilesData","obfBoard","all","buttons","map","tileButton","loadBoardData","path","loadBoard","imageID","image","imageData","contentType","url","API","uploadFromDataURL","apiURL","console","log","message","Object","keys","filter","k","startsWith","forEach","key","tileKey","slice","length","tiles","obfToCboard","allBoards","getBoardsIds","includes","undefined","board","name","locale","allBoardsIds","push","prevId","intl","JSON","parse","fboards","ext_cboard_hidden","readAsText","zipFile","Error","files","boardKeys","dir","endsWith","imageKeys","isBoard","indexOf","type","async","tempBoard","substring","cboardBoards","jsonFile","requestQuota","size","stringify","navigator","webkitPersistentStorage","grantedSize","createStandardXHR","window","XMLHttpRequest","e","_getBinaryFromXHR","xhr","response","responseText","createXHR","ActiveXObject","createActiveXHR","options","promise","callback","_resolve","_reject","open","responseType","overrideMimeType","onreadystatechange","status","this","statusText","progress","onprogress","originalEvent","percent","loaded","total","send","module","exports"],"mappings":"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","file":"static/js/2.c40015c1.chunk.js","sourcesContent":["import {\r\n  cboardImportAdapter,\r\n  obzImportAdapter,\r\n  obfImportAdapter\r\n} from './Import.helpers';\r\nimport {\r\n  CBOARD_EXT_PROPERTIES as EXPORT_CBOARD_EXT_PROPERTIES,\r\n  CBOARD_EXT_PREFIX as EXPORT_CBOARD_EXT_PREFIX\r\n} from '../Export/Export.constants';\r\n\r\nexport const IMPORT_CONFIG_BY_EXTENSION = {\r\n  json: cboardImportAdapter,\r\n  zip: obzImportAdapter,\r\n  obz: obzImportAdapter,\r\n  obf: obfImportAdapter\r\n};\r\n\r\nexport const IMPORT_PATHS = {\r\n  boards: '.obf',\r\n  images: 'images/'\r\n};\r\n\r\nexport const CBOARD_EXT_PREFIX = EXPORT_CBOARD_EXT_PREFIX;\r\n\r\nexport const CBOARD_EXT_PROPERTIES = EXPORT_CBOARD_EXT_PROPERTIES;\r\n\r\nexport default {\r\n  IMPORT_CONFIG_BY_EXTENSION,\r\n  IMPORT_PATHS,\r\n  CBOARD_EXT_PREFIX,\r\n  CBOARD_EXT_PROPERTIES\r\n};\r\n","import JSZipUtils from 'jszip-utils';\r\nimport JSZip from 'jszip';\r\nimport shortid from 'shortid';\r\nimport { IMPORT_PATHS, CBOARD_EXT_PREFIX } from './Import.constants';\r\nimport API from '../../../api';\r\n\r\nfunction toCamelCase(scString = '') {\r\n  const find = /(_\\w)/g;\r\n  const convertFn = matches => matches[1].toUpperCase();\r\n\r\n  return scString.replace(find, convertFn);\r\n}\r\n\r\nasync function readZip(file) {\r\n  const zipBlob = await new Promise(resolve => {\r\n    const reader = new FileReader();\r\n    reader.onload = event => {\r\n      if (event.target.readyState === 2) {\r\n        try {\r\n          resolve(new Blob([reader.result]));\r\n        } catch (err) {\r\n          resolve(null);\r\n        }\r\n      }\r\n    };\r\n    reader.readAsArrayBuffer(file);\r\n  });\r\n\r\n  if (zipBlob === null) {\r\n    return Promise.reject();\r\n  }\r\n\r\n  const filePath = URL.createObjectURL(zipBlob);\r\n  return new Promise(resolve => {\r\n    JSZipUtils.getBinaryContent(filePath, (err, data) => {\r\n      if (err) {\r\n        resolve(err);\r\n      } else {\r\n        resolve(JSZip.loadAsync(data));\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nfunction obfButtonToCboardButton(button) {\r\n  const cboardButton = {\r\n    id: button.id || shortid.generate(),\r\n    label: button.label || ''\r\n  };\r\n\r\n  if (button['background_color']) {\r\n    cboardButton.backgroundColor = button['background_color'];\r\n  }\r\n\r\n  if (button['border_color']) {\r\n    cboardButton.borderColor = button['border_color'];\r\n  }\r\n\r\n  if (button.vocalization) {\r\n    cboardButton.vocalization = button.vocalization;\r\n  }\r\n\r\n  if (button.action) {\r\n    cboardButton.action = button.action;\r\n  }\r\n\r\n  return cboardButton;\r\n}\r\n\r\nasync function getTilesData(obfBoard, boards = {}, images = {}) {\r\n  const tiles = await Promise.all(\r\n    obfBoard.buttons.map(async button => {\r\n      const tileButton = obfButtonToCboardButton(button);\r\n\r\n      if (button['load_board']) {\r\n        const loadBoardData = button['load_board'];\r\n        if (loadBoardData.path && boards[loadBoardData.path]) {\r\n          tileButton.loadBoard = boards[loadBoardData.path].id;\r\n        }\r\n      }\r\n\r\n      if (button['image_id']) {\r\n        let imageID = button['image_id'];\r\n        let image = obfBoard.images.find(image => image.id === imageID);\r\n\r\n        if (image) {\r\n          let imageData = image.data || null;\r\n          if (image['content_type'] && image.path && images[image.path]) {\r\n            // Certain OBF files have an incorrect MIME type for SVG files, so\r\n            // the resulting data URI cannot be rendered. We need to fix the\r\n            // MIME type ourselves.\r\n            const contentType =\r\n              image['content_type'] === 'image/svg'\r\n                ? 'image/svg+xml'\r\n                : image['content_type'];\r\n            imageData = `data:${contentType};base64,${images[image.path]}`;\r\n          }\r\n          if (image.url) {\r\n            tileButton.image = image.url;\r\n          }\r\n          if (imageData) {\r\n            let url = imageData;\r\n            try {\r\n              const apiURL = await API.uploadFromDataURL(url, imageID, true);\r\n              url = apiURL || url;\r\n            } catch (err) {\r\n              console.log(err.message);\r\n            } finally {\r\n              tileButton.image = url;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const extKeys = Object.keys(button).filter(k =>\r\n        k.startsWith(CBOARD_EXT_PREFIX)\r\n      );\r\n      extKeys.forEach(key => {\r\n        const tileKey = toCamelCase(key.slice(CBOARD_EXT_PREFIX.length));\r\n        tileButton[tileKey] = button[key];\r\n      });\r\n\r\n      return tileButton;\r\n    })\r\n  );\r\n\r\n  return tiles;\r\n}\r\n\r\nasync function obfToCboard(obfBoard, boards = {}, images = {}, allBoards = []) {\r\n  const allBoardsIds = getBoardsIds(allBoards);\r\n  if (allBoardsIds.includes(obfBoard.id)) {\r\n    return undefined;\r\n  }\r\n  let tiles = [];\r\n  if (obfBoard.buttons) {\r\n    tiles = await getTilesData(obfBoard, boards, images);\r\n  }\r\n  let board = {\r\n    id: obfBoard.id || shortid.generate(),\r\n    tiles\r\n  };\r\n\r\n  const extKeys = Object.keys(obfBoard).filter(k =>\r\n    k.startsWith(CBOARD_EXT_PREFIX)\r\n  );\r\n  extKeys.forEach(key => {\r\n    const tileKey = toCamelCase(key.slice(CBOARD_EXT_PREFIX.length));\r\n    board[tileKey] = obfBoard[key];\r\n  });\r\n  if (typeof obfBoard.name !== 'undefined') {\r\n    board.name = obfBoard.name;\r\n  } else {\r\n    board.name = 'unknown name';\r\n  }\r\n\r\n  if (obfBoard.locale) {\r\n    board.locale = obfBoard.locale;\r\n  }\r\n\r\n  return board;\r\n}\r\n\r\nfunction getBoardsIds(boards) {\r\n  const allBoardsIds = [];\r\n  boards.forEach(board => {\r\n    if (typeof board.id !== 'undefined') {\r\n      allBoardsIds.push(board.id);\r\n    }\r\n    if (typeof board.prevId !== 'undefined') {\r\n      allBoardsIds.push(board.prevId);\r\n    }\r\n  });\r\n  return allBoardsIds;\r\n}\r\n\r\nexport async function cboardImportAdapter(file, intl, allBoards) {\r\n  const reader = new FileReader();\r\n  return new Promise((resolve, reject) => {\r\n    reader.onload = async event => {\r\n      if (event.target.readyState === 2) {\r\n        try {\r\n          const boards = JSON.parse(reader.result);\r\n          const allBoardsIds = getBoardsIds(allBoards);\r\n          const fboards = boards.filter(board => (typeof board.ext_cboard_hidden === 'undefined' ||\r\n            !board.ext_cboard_hidden) &&\r\n            board.id !== 'root' &&\r\n            !allBoardsIds.includes(board.id));\r\n          resolve(fboards);\r\n        } catch (err) {\r\n          reject(err);\r\n        }\r\n      }\r\n    };\r\n    reader.readAsText(file);\r\n  });\r\n}\r\n\r\nexport async function obzImportAdapter(file, intl, allBoards) {\r\n  const zipFile = await readZip(file);\r\n  if (typeof zipFile !== 'object') {\r\n    throw new Error(zipFile);\r\n  }\r\n\r\n  const keys = Object.keys(zipFile.files);\r\n  const boardKeys = keys.filter(\r\n    k => !zipFile.files[k].dir && k.endsWith(IMPORT_PATHS.boards)\r\n  );\r\n  const imageKeys = keys.filter(\r\n    k => !zipFile.files[k].dir && k.startsWith(IMPORT_PATHS.images)\r\n  );\r\n  const boards = {};\r\n  const images = {};\r\n  const allBoardsIds = getBoardsIds(allBoards);\r\n  await Promise.all(\r\n    keys.map(async k => {\r\n      const isBoard = boardKeys.indexOf(k) >= 0;\r\n\r\n      if (!isBoard && imageKeys.indexOf(k) < 0) {\r\n        return Promise.resolve();\r\n      }\r\n\r\n      const type = isBoard ? 'text' : 'base64';\r\n      let result = null;\r\n      try {\r\n        result = await zipFile.files[k].async(type);\r\n\r\n        if (isBoard) {\r\n          const tempBoard = JSON.parse(result);\r\n          if (\r\n            (typeof tempBoard.ext_cboard_hidden === 'undefined' ||\r\n              !tempBoard.ext_cboard_hidden) &&\r\n            tempBoard.id !== 'root' &&\r\n            !allBoardsIds.includes(tempBoard.id)\r\n          ) {\r\n            boards[k] = tempBoard;\r\n          }\r\n        } else {\r\n          if (k.startsWith('images//')) {\r\n            images[k.substring(7)] = result;\r\n          } else {\r\n            images[k] = result;\r\n          }\r\n        }\r\n      } catch (e) {}\r\n\r\n      return result;\r\n    })\r\n  );\r\n\r\n  const cboardBoards = [];\r\n  for (let key in boards) {\r\n    const board = await obfToCboard(boards[key], boards, images);\r\n    cboardBoards.push(board);\r\n  }\r\n\r\n  return cboardBoards;\r\n}\r\n\r\nexport async function obfImportAdapter(file, intl, allBoards) {\r\n  const reader = new FileReader();\r\n  const jsonFile = await new Promise(resolve => {\r\n    reader.onload = event => {\r\n      if (event.target.readyState === 2) {\r\n        try {\r\n          const jsonFile = JSON.parse(reader.result);\r\n          resolve(jsonFile);\r\n        } catch (err) {\r\n          resolve(err);\r\n        }\r\n      }\r\n    };\r\n    reader.readAsText(file);\r\n  });\r\n\r\n  if (typeof jsonFile !== 'object') {\r\n    throw new Error(jsonFile);\r\n  }\r\n\r\n  const board = await obfToCboard(jsonFile, {}, {}, allBoards);\r\n  if (board) {\r\n    return [board];\r\n  }\r\n  return [];\r\n}\r\n\r\nexport async function requestQuota(json) {\r\n  const size = JSON.stringify(json).length;\r\n  if (size > 1024 * 1024 * 4) {\r\n    const requestQuotaAvailable =\r\n      navigator &&\r\n      navigator.webkitPersistentStorage &&\r\n      navigator.webkitPersistentStorage.requestQuota;\r\n    if (requestQuotaAvailable) {\r\n      try {\r\n        await new Promise((resolve, reject) => {\r\n          navigator.webkitPersistentStorage.requestQuota(\r\n            size * 2,\r\n            grantedSize => {\r\n              if (grantedSize >= size) {\r\n                resolve();\r\n              } else {\r\n                reject(`Granted size is below the limit: ${grantedSize}`);\r\n              }\r\n            },\r\n            err => reject(`Request quota error: ${err}`)\r\n          );\r\n        });\r\n      } catch (e) {\r\n        throw new Error(e);\r\n      }\r\n    } else {\r\n      throw new Error(\"Can't request quota\");\r\n    }\r\n  }\r\n\r\n  return size;\r\n}\r\n","'use strict';\n/*globals Promise */\n\nvar JSZipUtils = {};\n// just use the responseText with xhr1, response with xhr2.\n// The transformation doesn't throw away high-order byte (with responseText)\n// because JSZip handles that case. If not used with JSZip, you may need to\n// do it, see https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\nJSZipUtils._getBinaryFromXHR = function (xhr) {\n    // for xhr.responseText, the 0xFF mask is applied by JSZip\n    return xhr.response || xhr.responseText;\n};\n\n// taken from jQuery\nfunction createStandardXHR() {\n    try {\n        return new window.XMLHttpRequest();\n    } catch( e ) {}\n}\n\nfunction createActiveXHR() {\n    try {\n        return new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n    } catch( e ) {}\n}\n\n// Create the request object\nvar createXHR = (typeof window !== \"undefined\" && window.ActiveXObject) ?\n    /* Microsoft failed to properly\n     * implement the XMLHttpRequest in IE7 (can't request local files),\n     * so we use the ActiveXObject when it is available\n     * Additionally XMLHttpRequest can be disabled in IE7/IE8 so\n     * we need a fallback.\n     */\n    function() {\n    return createStandardXHR() || createActiveXHR();\n} :\n    // For all other browsers, use the standard XMLHttpRequest object\n    createStandardXHR;\n\n\n/**\n * @param  {string} path    The path to the resource to GET.\n * @param  {function|{callback: function, progress: function}} options\n * @return {Promise|undefined} If no callback is passed then a promise is returned\n */\nJSZipUtils.getBinaryContent = function (path, options) {\n    var promise, resolve, reject;\n    var callback;\n\n    if (!options) {\n        options = {};\n    }\n\n    // backward compatible callback\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    } else if (typeof options.callback === 'function') {\n        // callback inside options object\n        callback = options.callback;\n    }\n\n    if (!callback && typeof Promise !== \"undefined\") {\n        promise = new Promise(function (_resolve, _reject) {\n            resolve = _resolve;\n            reject = _reject;\n        });\n    } else {\n        resolve = function (data) { callback(null, data); };\n        reject = function (err) { callback(err, null); };\n    }\n\n    /*\n     * Here is the tricky part : getting the data.\n     * In firefox/chrome/opera/... setting the mimeType to 'text/plain; charset=x-user-defined'\n     * is enough, the result is in the standard xhr.responseText.\n     * cf https://developer.mozilla.org/En/XMLHttpRequest/Using_XMLHttpRequest#Receiving_binary_data_in_older_browsers\n     * In IE <= 9, we must use (the IE only) attribute responseBody\n     * (for binary data, its content is different from responseText).\n     * In IE 10, the 'charset=x-user-defined' trick doesn't work, only the\n     * responseType will work :\n     * http://msdn.microsoft.com/en-us/library/ie/hh673569%28v=vs.85%29.aspx#Binary_Object_upload_and_download\n     *\n     * I'd like to use jQuery to avoid this XHR madness, but it doesn't support\n     * the responseType attribute : http://bugs.jquery.com/ticket/11461\n     */\n    try {\n        var xhr = createXHR();\n\n        xhr.open('GET', path, true);\n\n        // recent browsers\n        if (\"responseType\" in xhr) {\n            xhr.responseType = \"arraybuffer\";\n        }\n\n        // older browser\n        if(xhr.overrideMimeType) {\n            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n        }\n\n        xhr.onreadystatechange = function (event) {\n            // use `xhr` and not `this`... thanks IE\n            if (xhr.readyState === 4) {\n                if (xhr.status === 200 || xhr.status === 0) {\n                    try {\n                        resolve(JSZipUtils._getBinaryFromXHR(xhr));\n                    } catch(err) {\n                        reject(new Error(err));\n                    }\n                } else {\n                    reject(new Error(\"Ajax error for \" + path + \" : \" + this.status + \" \" + this.statusText));\n                }\n            }\n        };\n\n        if(options.progress) {\n            xhr.onprogress = function(e) {\n                options.progress({\n                    path: path,\n                    originalEvent: e,\n                    percent: e.loaded / e.total * 100,\n                    loaded: e.loaded,\n                    total: e.total\n                });\n            };\n        }\n\n        xhr.send();\n\n    } catch (e) {\n        reject(new Error(e), null);\n    }\n\n    // returns a promise or undefined depending on whether a callback was\n    // provided\n    return promise;\n};\n\n// export\nmodule.exports = JSZipUtils;\n\n// enforcing Stuk's coding style\n// vim: set shiftwidth=4 softtabstop=4:\n"],"sourceRoot":""}